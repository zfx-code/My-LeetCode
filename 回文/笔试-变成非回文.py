"""
https://codeforces.com/problemset/problem/1466/C

我们称一首诗的子串为回文，当且仅当它前后读起来相同。如果A可以通过从b中删除开头的几个字符(可能为零或全部)和末尾的几个字符(可能为零或全部)来获得，那么字符串A就是字符串b的子字符串。

不幸的是，Cerberus不喜欢长度大于1的回文。比如在诗歌abaa中哈迪斯的猎犬不喜欢子字符串aba和aa。

俄耳甫斯只有在猎犬喜欢他的诗歌时才能使它平静下来。这就是为什么他想改变他的诗，使它不包含任何长度大于1的回文子串

俄耳甫斯可以修改这首诗，用任何小写的英文字母替换任何位置的一个字母。他可以任意多次使用这个操作(可能为零)。由于他的诗中可能有很多回文，他可能不得不做一些修改。但究竟有多少呢?给定这首诗，确定必须更改的最小字母数量，以使这首诗不包含任何长度大于1的回文

##################################################
首先可以知道如果我们要消灭长度>=4的回文串，那么这个大的回文串必然包含小的回文串。所以我们其实只要消灭小的回文串就可以了。其实就是干掉aaa、aba、aa这三种。那么对于很长的一串回文串我们要使其任何子串都无长度>=2的回文串，我们从头开始遍历。如果开始出现aa,贪心一下我们干掉第二个字符，这样会尽可能减少a与之后的形成回文串。类似，aaa干掉后两个，aba干掉第三个，细节见代码。
"""

def solve_C(s):
    n = len(s)
    ans = 0 

    for i in range(n):
        if s[i] == "#":
            continue 
        
        # "aba"
        if i + 2 < n and s[i] == s[i + 2]:
            s[i + 2] = "#"
            ans += 1
        
        if i + 1 < n and s[i] == s[i + 1]:
            s[i + 1] = "#"
            ans += 1 
    
    print(ans)

