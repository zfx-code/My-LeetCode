"""
887. 鸡蛋掉落

给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。

已知存在楼层 f ，满足 0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。

每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。

请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？

 
示例 1：

输入：k = 1, n = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 
否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 
如果它没碎，那么肯定能得出 f = 2 。 
因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 
示例 2：

输入：k = 2, n = 6
输出：3
示例 3：

输入：k = 3, n = 14
输出：4

"""

class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        """
        https://leetcode.cn/problems/super-egg-drop/solutions/28523/887-by-ikaruga/
        (1) 概念定义
            N: 一栋楼, 层数为1,..., N(共N层)
            F: in [0, N], 当>F时, 一定碎, <=F不会碎
        (2) 问题描述
            from (N层楼, 有K个蛋, 问最少扔T次, 保证找到F in [0, N])
            to   (有K个蛋, 扔T次, 求可以确定F的个数, 然后得出N个楼层)
        (3) 通过扔蛋, 怎样确定F, 怎样确定全部的F
            eg: N=1
            在1层扔, 碎了, 所以F<1  => F in [0, N] => F=0 
            在1层扔, 没碎, 所以F>=1 => F=1 

            eg: N=2
            在1层扔, 碎了, 所以F<1    => F=0 
            在1层扔, 没碎, 但2层扔碎了 => 所以F>=1 and F < 2 => F=1 
            在2层扔, 没碎 => 所以F>=2  => F=2 
        (4) 边界情况, 只有1个蛋
            只能从低到高, 一层层判断(唯一的蛋碎了无法继续测试)
            有T个蛋, 可以确定出T+1个F
        (5) 边界情况, 只有1次机会
            等于只有1个蛋扔一次, 确定2个F => T(1)+1个F
        (6) 计算确定F的个数 
            (6.1) 只有1个蛋/1次机会, 确定出T+1个F
            (6.?) (蛋碎了, 机会-1) + (蛋没碎, 机会-1)
        (7) 题目已知K, N, 不断增加T, 当计算出F个数超过N+1时, 可以确定答案
        """
        from functools import cache 

        @cache
        def calcF(K, T):
            if T == 1 or K == 1:
                return T + 1 
            # 扔了1次: 碎 + 没碎
            return calcF(K - 1, T - 1) + calcF(K, T - 1)
        
        T = 1 
        while calcF(k, T) < n + 1:
            T += 1 
        
        return T